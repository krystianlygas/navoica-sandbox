{"version":3,"sources":["webpack:///./lms/static/completion/js/ViewedEvent.js"],"names":["throttle","fn","wait","time","delay","now","Date","ElementViewing","el","viewedAfterMs","callback","topSeen","bottomSeen","seenForMs","becameVisibleAt","undefined","hasBeenViewed","getBoundingClientRect","setTimeout","checkIfViewed","getTotalTimeSeen","areViewedCriteriaMet","elementHasBeenViewed","ViewedEventTracker","elements","elementViewings","Set","handlers","interval","forEach","add","element","event","callHandlers","registerDomHandlers","handler","push","elv","rect","getBoundingRect","visible","top","window","innerHeight","markTopSeen","bottom","markBottomSeen","handleVisible","handleNotVisible","onscroll","updateVisible","onresize"],"mappings":"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","file":"ViewedEvent.js","sourcesContent":["/** Ensure that a function is only run once every `wait` milliseconds */\nfunction throttle(fn, wait) {\n  let time = 0;\n  function delay() {\n    // Do not call the function until at least `wait` seconds after the\n    // last time the function was called.\n    const now = Date.now();\n    if (time + wait < now) {\n      time = now;\n      fn();\n    }\n  }\n  return delay;\n}\n\n\nexport class ElementViewing {\n  /**\n   * A wrapper for an HTMLElement that tracks whether the element has been\n   * viewed or not.\n   */\n  constructor(el, viewedAfterMs, callback) {\n    this.el = el;\n    this.viewedAfterMs = viewedAfterMs;\n    this.callback = callback;\n\n    this.topSeen = false;\n    this.bottomSeen = false;\n    this.seenForMs = 0;\n    this.becameVisibleAt = undefined;\n    this.hasBeenViewed = false;\n  }\n\n  getBoundingRect() {\n    return this.el.getBoundingClientRect();\n  }\n\n  /** This element has become visible on screen.\n   *\n   * (may be called even when already on screen though)\n   */\n  handleVisible() {\n    if (!this.becameVisibleAt) {\n      this.becameVisibleAt = Date.now();\n      // We're now visible; after viewedAfterMs, if the top and bottom have been\n      // seen, this block will count as viewed.\n      setTimeout(\n        () => {\n          this.checkIfViewed();\n        },\n        this.viewedAfterMs - this.seenForMs,\n      );\n    }\n  }\n\n  handleNotVisible() {\n    if (this.becameVisibleAt) {\n      this.seenForMs = Date.now() - this.becameVisibleAt;\n    }\n    this.becameVisibleAt = undefined;\n  }\n\n  markTopSeen() {\n    // If this element has been seen for enough time, but the top wasn't visible, it may now be\n    // considered viewed.\n    this.topSeen = true;\n    this.checkIfViewed();\n  }\n\n  markBottomSeen() {\n    this.bottomSeen = true;\n    this.checkIfViewed();\n  }\n\n  getTotalTimeSeen() {\n    if (this.becameVisibleAt) {\n      return this.seenForMs + (Date.now() - this.becameVisibleAt);\n    }\n    return this.seenForMs;\n  }\n\n  areViewedCriteriaMet() {\n    return this.topSeen && this.bottomSeen && (this.getTotalTimeSeen() >= this.viewedAfterMs);\n  }\n\n  checkIfViewed() {\n    // User can provide a \"now\" value for testing purposes.\n    if (this.hasBeenViewed) {\n      return;\n    }\n    if (this.areViewedCriteriaMet()) {\n      this.hasBeenViewed = true;\n      // Report to the tracker that we have been viewed\n      this.callback(this.el, { elementHasBeenViewed: this.hasBeenViewed });\n    }\n  }\n}\n\n\nexport class ViewedEventTracker {\n  /**\n   * When the top or bottom of an element is first viewed, and the entire\n   * element is viewed for a specified amount of time, the callback is called,\n   * passing the element that was viewed, and an event object having the\n   * following field:\n   *\n   * *   hasBeenViewed (bool): true if all the conditions for being\n   *     considered \"viewed\" have been met.\n   */\n  constructor(elements, viewedAfterMs) {\n    this.viewedAfterMs = viewedAfterMs;\n    this.elementViewings = new Set();\n    this.handlers = [];\n\n    this.interval = undefined;\n    elements.forEach((el) => {\n      this.elementViewings.add(\n        new ElementViewing(\n          el,\n          viewedAfterMs,\n          (element, event) => this.callHandlers(element, event),\n        ),\n      );\n    });\n    this.registerDomHandlers();\n  }\n\n  /** Register a new handler to be called when an element has been viewed.  */\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  /** Mark which elements are currently visible.\n   *\n   *  Also marks when an elements top or bottom has been seen.\n   * */\n  updateVisible() {\n    this.elementViewings.forEach((elv) => {\n      if (elv.hasBeenViewed) {\n        return;\n      }\n\n      const now = Date.now(); // Use the same \"now\" for all calculations\n      const rect = elv.getBoundingRect();\n      let visible = false;\n\n      if (rect.top > 0 && rect.top < window.innerHeight) {\n        elv.markTopSeen(now);\n        visible = true;\n      }\n      if (rect.bottom > 0 && rect.bottom < window.innerHeight) {\n        elv.markBottomSeen(now);\n        visible = true;\n      }\n      if (rect.top < 0 && rect.bottom > window.innerHeight) {\n        visible = true;\n      }\n\n      if (visible) {\n        elv.handleVisible(now);\n      } else {\n        elv.handleNotVisible(now);\n      }\n    });\n  }\n\n  registerDomHandlers() {\n    window.onscroll = throttle(() => this.updateVisible(), 100);\n    window.onresize = throttle(() => this.updateVisible(), 100);\n    this.updateVisible();\n  }\n\n  /** Call the handlers for all newly-viewed elements and pause tracking\n   *  for recently disappeared elements.\n   */\n  callHandlers(el, event) {\n    this.handlers.forEach((handler) => {\n      handler(el, event);\n    });\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lms/static/completion/js/ViewedEvent.js"],"sourceRoot":""}